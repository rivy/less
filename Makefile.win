# Makefile for `less`
# Cross-platform (bash/sh + CMD/PowerShell)
# `cl`, `clang`, and `gcc` (defaults to `CC=clang`)
# GNU make (gmake) compatible; ref: <https://www.gnu.org/software/make/manual>
# Copyright (C) 2020 ~ Roy Ivy III <rivy.dev@gmail.com>; MIT+Apache-2.0 license

# NOTE: * requires `make` version 4.0+ (minimum needed for correct path functions)
# NOTE: `make` doesn't handle spaces within file names without gyrations (see <https://stackoverflow.com/questions/9838384/can-gnu-make-handle-filenames-with-spaces>@@<https://archive.is/PYKKq>)

# `make -f Makefile.win`

NAME := less ## empty/null => autoset to name of containing folder

####

# spell-checker:ignore () brac cmdbuf forwback funcs ifile lessecho lesskey linenum lsystem optfunc opttbl scrsize ttyin

# spell-checker:ignore (targets) realclean vclean veryclean
# spell-checker:ignore (make) CURDIR MAKEFLAGS SHELLSTATUS TERMERR TERMOUT abspath addprefix addsuffix endef eval findstring firstword gmake ifeq ifneq lastword notdir prepend undefine wordlist
#
# spell-checker:ignore (CC) DDEBUG DNDEBUG NDEBUG Ofast Werror Wextra Xclang Xlinker dumpmachine flto flto-visibility-public-std fpie nodefaultlib nologo nothrow
# spell-checker:ignore (abbrev/acronyms) LLVM MSVC MinGW POSIX VCvars
# spell-checker:ignore (jargon) autoset deps delims executables maint multilib
# spell-checker:ignore (libraries) libcmt libgcc libstdc lmsvcrt lstdc stdext
# spell-checker:ignore (names) benhoyt rivy Borland
# spell-checker:ignore (shell/nix) mkdir printf rmdir uname
# spell-checker:ignore (shell/win) COMSPEC SystemDrive SystemRoot findstr findstring mkdir windir
# spell-checker:ignore (utils) goawk ilink
# spell-checker:ignore (vars) BQUOTE CFLAGS CPPFLAGS CXXFLAGS DEFINETYPE DQUOTE EXEEXT LDFLAGS LIBDIR LIBPATH MAKEDIR OBJ_deps OSID PAREN SQUOTE devnull falsey fileset punct truthy

####

OSID := $(or $(and $(filter .exe,$(patsubst %.exe,.exe,$(subst $() $(),_,${SHELL}))),$(filter win,${OS:Windows_NT=win})),nix)## OSID == [nix,win]
# for Windows OS, set SHELL to `%ComSpec%` or `cmd` (note: environment/${OS}=="Windows_NT" for XP, 2000, Vista, 7, 10 ...)
# * `make` may otherwise use an incorrect shell (eg, `bash`), if found; "syntax error: unexpected end of file" error output is indicative
ifeq (${OSID},win)
# use case and location fallbacks; note: assumes *no spaces* within ${ComSpec}, ${SystemRoot}, or ${windir}
COMSPEC := $(or ${ComSpec},${COMSPEC},${comspec})
SystemRoot := $(or ${SystemRoot},${SYSTEMROOT},${systemroot},${windir})
SHELL := $(firstword $(wildcard ${COMSPEC} ${SystemRoot}/System32/cmd.exe) cmd)
endif

#### Start of system configuration section. ####

# * default to `clang` (fallback to `gcc`; via a portable shell test)
CC := $(and $(filter-out default,$(origin CC)),${CC})## use any non-make defined value as default ## note: used to avoid requiring a recursive definition of ${CC} with I/O in the later default determination
CC := $(or ${CC},$(subst -FOUND,,$(filter clang-FOUND,$(shell clang --version 2>&1 && echo clang-FOUND))),gcc)

CC_ID := $(lastword $(subst -,$() $(),${CC}))

ifeq (,$(filter-out clang gcc,${CC_ID}))
## `clang` or `gcc`
CXX := ${CC:gcc=g}++
LD := ${CXX}
STRIP_CC_clang_OSID_nix := strip
STRIP_CC_clang_OSID_win := llvm-strip
STRIP_CC_gcc := strip
## -g :: produce debugging information
## -v :: verbose output (shows command lines used during run)
## -O<n> :: <n> == [0 .. 3], increasing level of optimization (see <https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html> @@ <https://archive.vn/7YtdI>)
## -pedantic-errors :: error on use of compiler language extensions
## -Werror :: warnings treated as errors
## -Wall :: enable all (usual) warnings
## -Wextra :: enable extra warnings
## -Wno-comment :: suppress warnings about trailing comments on directive lines
## -Wno-deprecated-declarations :: suppress deprecation warnings
## -Wno-int-to-void-pointer-cast :: suppress cast to void from int warnings; ref: <https://stackoverflow.com/questions/22751762/how-to-make-compiler-not-show-int-to-void-pointer-cast-warnings>
## -D_CRT_SECURE_NO_WARNINGS :: compiler directive == suppress "unsafe function" compiler warning
## note: CFLAGS == C flags; CPPFLAGS == C PreProcessor flags; CXXFLAGS := C++ flags; ref: <https://stackoverflow.com/questions/495598/difference-between-cppflags-and-cxxflags-in-gnu-make>
CFLAGS := -I. -pedantic-errors -Werror -Wall -Wno-comment -Wno-deprecated-declarations -D_CRT_SECURE_NO_WARNINGS
CFLAGS_COMPILE_ONLY := -c
CFLAGS_ARCH_32 := -m32
CFLAGS_ARCH_64 := -m64
CFLAGS_DEBUG_true := -DDEBUG -O0 -g
CFLAGS_DEBUG_false := -DNDEBUG -O3
CFLAGS_VERBOSE_true := -v
CFLAGS_machine := -dumpmachine
CFLAGS_v := --version
CPPFLAGS := $()
## see <https://stackoverflow.com/questions/42545078/clang-version-5-and-lnk4217-warning/42752769#42752769>@@<https://archive.is/bK4Di>
## see <http://clang-developers.42468.n3.nabble.com/MinGW-Clang-issues-with-static-libstdc-td4056214.html>
## see <https://clang.llvm.org/docs/LTOVisibility.html>
## -Xclang <arg> :: pass <arg> to clang compiler
## -flto-visibility-public-std :: use public LTO visibility for classes in std and stdext namespaces
CXXFLAGS := $()
CXXFLAGS_clang := -Xclang -flto-visibility-public-std
## -Xlinker <arg> :: pass <arg> to linker
## --strip-all :: strip all symbols
LDFLAGS := $()
LDFLAGS_ARCH_32 := -m32
LDFLAGS_ARCH_64 := -m64
LDFLAGS_DEBUG_false := -Xlinker --strip-all
# LDFLAGS_STATIC_true := -static -static-libgcc -static-libstdc++
LDFLAGS_STATIC_true := -static
LDFLAGS_clang_nix := -lstdc++
LDFLAGS_gcc := -lstdc++

LIBS := $()

# ifeq ($(CC),clang)
# LDFLAGS_dynamic := -Wl,-nodefaultlib:libcmt -lmsvcrt # only works for MSVC targets
# endif
# ifeq ($(CC),gcc)
# # CFLAGS_dynamic := -fpie
# # LDFLAGS_dynamic := -fpie
# endif
endif ## `clang` or `gcc`

ifeq (cl,${CC_ID})
CXX := cl
LD := link
STRIP := $()
## `cl` (MSVC)
## ref: <https://docs.microsoft.com/en-us/cpp/build/reference/compiler-options-listed-by-category> @@ <https://archive.is/PTPDN>
## /nologo :: startup without logo display
## /W3 :: set warning level to 3 [1..4, all; increasing level of warning scrutiny]
## /WX :: treat warnings as errors
## /wd4996 :: suppress POSIX function name deprecation warning (#C4996)
## /EHsc :: enable C++ EH (no SEH exceptions) + extern "C" defaults to nothrow (replaces deprecated /GX)
## /D "_CRT_SECURE_NO_WARNING" :: compiler directive == suppress "unsafe function" compiler warning
## /Od :: disable optimization
## /Ox :: maximum optimizations
## /O2 :: maximize speed
## /D "WIN32" :: old/extraneous define
## /D "_CONSOLE" :: old/extraneous define
## /D "DEBUG" :: activate DEBUG changes
## /D "NDEBUG" :: deactivate assert()
## /D "_CRT_SECURE_NO_WARNING" :: compiler directive == suppress "unsafe function" compiler warning
## /MT :: static linking
## /MTd :: static debug linking
## /Fd:... :: program database file name
## /Zi :: generate complete debug information (as a *.PDB file)
## /Z7 :: generate complete debug information within each object file (no *.PDB file)
## * `link`
## ref: <https://docs.microsoft.com/en-us/cpp/build/reference/linker-options> @@ <https://archive.is/wip/61bbL>
## /subsystem:console :: generate "Win32 character-mode" console application
## /incremental:no :: disable incremental linking (avoids size increase, useless for cold builds, with minimal time cost)
## /machine:I386 :: specify the target machine platform
CFLAGS := /nologo /W3 /WX /EHsc /I "." /D "WIN32" /D "_CONSOLE" /D "_CRT_SECURE_NO_WARNINGS"
CFLAGS_COMPILE_ONLY := -c
# CFLAGS_DEBUG_true = /D "DEBUG" /D "_DEBUG" /Od /Zi /Fd"${OUT_obj}/"
CFLAGS_DEBUG_true := /D "DEBUG" /D "_DEBUG" /Od /Z7
CFLAGS_DEBUG_false := /D "NDEBUG" /Ox /O2
CFLAGS_DEBUG_true_STATIC_false := /MDd ## debug + dynamic
CFLAGS_DEBUG_false_STATIC_false := /MD ## release + dynamic
CFLAGS_DEBUG_true_STATIC_true := /MTd ## debug + static
CFLAGS_DEBUG_false_STATIC_true := /MT ## release + static
CFLAGS_VERBOSE_true := $()
CPPFLAGS := $()
CXXFLAGS := $()
LDFLAGS := /nologo /subsystem:console /incremental:no
LDFLAGS_ARCH_32 := /machine:I386
# VC6-specific flags
## /ignore:4254 :: suppress "merging sections with different attributes" warning (LNK4254)
LDFLAGS_VC6_true := /ignore:4254

LIBS := user32.lib
endif ## `cl` (MSVC)

# ifeq (bcc32,${CC_ID})
# # NOTE: *untested* configuration
# CXX := ${CC_ID}
# LD := ilink32
# CFLAGS := -I. -O2 -w-pro -TWC -P-c -v- -d -f- -ff- -vi
# CFLAGS_COMPILE_ONLY := -c
# LDFLAGS := -Tpe -v- -ap -c -x -V4.0 -GF:AGGRESSIVE
# LIBDIR := $(MAKEDIR)\..\lib
# LIBS := ${LIBDIR}\import32.lib ${LIBDIR}\cw32.lib
# endif ## `bcc32` (Borland)

DEFINETYPE := wn
OBJ_deps := defines.h less.h funcs.h cmd.h

# `make` command line flags/options
COLOR := $(if $(or ${MAKE_TERMOUT},${MAKE_TERMERR}),true,false)## enable colorized output ('truthy'-type)
DEBUG := false## enable compiler debug flags/options ('truthy'-type; default == false)
STATIC := true## compile to statically linked executable ('truthy'-type; default == true)
VERBOSE := false## verbose `make` output ('truthy'-type; default == false)
MAKEFLAGS_debug := $(if $(findstring d,${MAKEFLAGS}),true,false)## Makefile debug output ('truthy'-type; default == false) ## NOTE: use `-d` or `MAKEFLAGS_debug=1`, `--debug[=FLAGS]` does not set MAKEFLAGS correctly (see <https://savannah.gnu.org/bugs/?func=detailitem&item_id=58341>)

#### End of system configuration section. ####

falsey := false 0 f n no off
false := $()
true := true
truthy := ${true}

devnull := $(if $(filter win,${OSID}),NUL,/dev/null)
int_max := 2147483647## largest signed 32-bit integer; used as arbitrary max expected list length

NULL := $()
BACKSLASH := $()\$()
COMMA := ,
DOT := .
ESC := $()$()## literal ANSI escape character (required for ANSI color display output; also used for some string matching)
HASH := \#
PAREN_OPEN := $()($()
PAREN_CLOSE := $())$()
SLASH := /
SPACE := $() $()

[lower] := a b c d e f g h i j k l m n o p q r s t u v w x y z
[upper] := A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
[alpha] := ${[lower]} ${[upper]}
[digit] := 1 2 3 4 5 6 7 8 9 0
[punct] := ~ ` ! @ ${HASH} ${DOLLAR} % ^ & * ${PAREN_OPEN} ${PAREN_CLOSE} _ - + = { } [ ] | ${BACKSLASH} : ; " ' < > ${COMMA} ? ${SLASH} ${DOT}

%not = $(if ${1},${false},$(or ${1},${true}))
%eq = $(or $(and $(findstring ${1},${2}),$(findstring ${2},${1})),$(if ${1}${2},${false},${true}))# note: `call %eq,$(),$()` => ${true}
%neq = $(if $(call %eq,${1},${2}),${false},$(or ${1},${2},${true}))# note: ${1} != ${2} => ${false}; ${1} == ${2} => first non-empty value (or ${true})

%falsey = $(firstword ${falsey})
%truthy = $(firstword ${truthy})

%as_truthy = $(if $(call %is_truthy,${1}),$(call %truthy),$(call %falsey))
%is_truthy = $(if $(filter-out ${falsey},$(call %lc,${1})),${true},${false})
%is_falsey = $(call %not,$(call %is_truthy,${1}))

%range = $(if $(word ${1},${2}),$(wordlist 1,${1},${2}),$(call %range,${1},${2} $(words _ ${2})))
%repeat = $(if $(word ${2},${1}),$(wordlist 1,${2},${1}),$(call %repeat,${1} ${1},${2}))

%head = $(firstword ${1})
%tail = $(words 2,${int_max},${1})
%chop = $(wordlist 2,$(words ${1}),_ ${1})
%append = ${2} ${1}
%prepend = ${1} ${2}
%length = $(words ${1})

%filter_map = $(strip $(foreach elem,${2},$(call ${1},${elem})))
%uniq = $(if ${1},$(firstword ${1}) $(call %uniq,$(filter-out $(firstword ${1}),${1})))

%tr = $(strip $(if ${1},$(call %tr,$(wordlist 2,$(words ${1}),${1}),$(wordlist 2,$(words ${2}),${2}),$(subst $(firstword ${1}),$(firstword ${2}),${3})),${3}))
%lc = $(call %tr,${[upper]},${[lower]},${1})
%uc = $(call %tr,${[lower]},${[upper]},${1})

ifeq (${OSID},win)
%rm_dir = if EXIST "${1}" ${RMDIR} "${1}" && echo $(call %info_text,"${1}" removed)
%rm_file = if EXIST "${1}" ${RM} "${1}" && echo $(call %info_text,"${1}" removed)
%rm_fileset = $(if $(shell for %%G in (${1}) do ${RM} "%%G" >${devnull} && echo done),$(shell echo echo $(call %info_text,"${1}" removed)),)
else
%rm_dir = ls -d "${1}" >${devnull} 2>&1 && { ${RMDIR} "${1}" && echo $(call %shell_quote,$(call %info_text,"${1}" removed)); } || true
%rm_file = ls -d "${1}" >${devnull} 2>&1 && { ${RM} "${1}" && echo $(call %shell_quote,$(call %info_text,"${1}" removed)); } || true
%rm_fileset = for file in ${1}; do ls -d "${1}" >${devnull} 2>&1 && ${RM} "$${file}"; done && echo $(call %shell_quote,$(call %info_text,"${1}" removed)) || true
endif

ifeq (${OSID},win)
%shell_quote = $(call %tr,^ | < > %,^^ ^| ^< ^> ^%,${1})
else
%shell_quote = '$(call %tr,','"'"',${1})'
endif

@mkdir_rule = ${1} : ${2} ; ${MKDIR} "$$@"

####

color_black := $(if $(call %is_truthy,${COLOR}),${ESC}[0;30m,)
color_blue := $(if $(call %is_truthy,${COLOR}),${ESC}[0;34m,)
color_cyan := $(if $(call %is_truthy,${COLOR}),${ESC}[0;36m,)
color_green := $(if $(call %is_truthy,${COLOR}),${ESC}[0;32m,)
color_magenta := $(if $(call %is_truthy,${COLOR}),${ESC}[0;35m,)
color_red := $(if $(call %is_truthy,${COLOR}),${ESC}[0;31m,)
color_yellow := $(if $(call %is_truthy,${COLOR}),${ESC}[0;33m,)
color_white := $(if $(call %is_truthy,${COLOR}),${ESC}[0;37m,)
color_reset := $(if $(call %is_truthy,${COLOR}),${ESC}[0m,)
#
color_success := ${color_green}
color_debug := ${color_cyan}
color_info := ${color_blue}
color_warning := ${color_yellow}
color_error := ${color_red}

%error_text = ${color_error}ERR!:${color_reset} ${1}
%debug_text = ${color_debug}debug:${color_reset} ${1}
%info_text = ${color_info}info:${color_reset} ${1}
%success_text = ${color_success}SUCCESS:${color_reset} ${1}
%warning_text = ${color_warning}WARN:${color_reset} ${1}
%error = $(error $(call %error_text,${1}))
%debug = $(if $(call %is_truthy,${MAKEFLAGS_debug}),$(info $(call %debug_text,${1})),)
%info = $(info $(call %info_text,${1}))
%success = $(info $(call %success_text,${1}))
%warning = $(warning $(call %warning_text,${1}))

%debug_var = $(call %debug,${1}="${${1}}")

####

override COLOR := $(call %as_truthy,${COLOR})
override DEBUG := $(call %as_truthy,${DEBUG})
override STATIC := $(call %as_truthy,${STATIC})
override VERBOSE := $(call %as_truthy,${VERBOSE})

override MAKEFLAGS_debug := $(call %as_truthy,$(or $(call %is_truthy,${MAKEFLAGS_debug}),$(call %is_truthy,${MAKEFILE_debug})))

$(call %debug_var,OSID)
$(call %debug_var,SHELL)

$(call %debug_var,CC)
$(call %debug_var,CXX)
$(call %debug_var,LD)
$(call %debug_var,CFLAGS)
$(call %debug_var,CPPFLAGS)
$(call %debug_var,CXXFLAGS)
$(call %debug_var,LDFLAGS)

$(call %debug_var,COLOR)
$(call %debug_var,DEBUG)
$(call %debug_var,STATIC)
$(call %debug_var,VERBOSE)

$(call %debug_var,MAKEFLAGS_debug)

####

# require at least `make` v4.0 (minimum needed for correct path functions)
MAKE_VERSION_major := $(word 1,$(subst ., ,$(MAKE_VERSION)))
MAKE_VERSION_minor := $(word 2,$(subst ., ,$(MAKE_VERSION)))
MAKE_VERSION_fail := $(filter $(MAKE_VERSION_major),3 2 1 0)
ifeq (${MAKE_VERSION_major},4)
MAKE_VERSION_fail := $(filter $(MAKE_VERSION_minor),)
endif
$(call %debug_var,MAKE_VERSION)
$(call %debug_var,MAKE_VERSION_major)
$(call %debug_var,MAKE_VERSION_minor)
$(call %debug_var,MAKE_VERSION_fail)
ifneq ($(MAKE_VERSION_fail),)
$(call %error,`make` v4.0+ required (currently using v${MAKE_VERSION}))
endif

####

# NOTE: early configuration; must be done before ${CC_ID} (`clang`) is used as a linker (eg, during configuration)
ifeq (${OSID},win)
ifeq (${CC_ID},clang)
# prior LIB definition may interfere with clang builds when using MSVC
undefine LIB # no 'override' to allow definition on command line
endif
endif
$(call %debug_var,LIB)

####

# detect ${CC}
CC_check_flags := $(if $(filter cl,${CC_ID}),,-v)
ifeq (,$(shell "${CC}" ${CC_check_flags} >${devnull} 2>&1 && echo ${CC} present))
$(call %error,Missing required compiler (`${CC}`))
endif

ifeq (${SPACE},$(findstring ${SPACE},${makefile_abs_path}))
$(call %error,<SPACE>'s within project directory may cause issues)
endif

# Since we rely on paths relative to the makefile location, abort if make isn't being run from there.
ifneq ($(makefile_dir),$(current_dir))
$(call %error,Invalid current directory; this makefile must be invoked from the directory it resides in)
endif

####

OS_PREFIX=
ifeq (${OSID},win)
OSID_name  := windows
OS_PREFIX  := win.
CC_e       := $(or $(if $(filter cl,${CC_ID}),/Fe),-o${SPACE})
CC_o       := $(or $(if $(filter cl,${CC_ID}),/Fo),-o${SPACE})
LD_o       := $(or $(if $(filter cl,${CC_ID}),/out:),-o${SPACE})
EXEEXT     := .exe
O          := $(if $(filter cl,${CC_ID}),obj,o)
#
AWK        := gawk ## from `scoop install gawk`; or "goawk" from `go get github.com/benhoyt/goawk`
CAT        := "${SystemRoot}\System32\findstr" /r .*
CP         := copy /y
ECHO       := echo
GREP       := grep ## from `scoop install grep`
MKDIR      := mkdir
RM         := del
RM_r       := $(RM) /s
RMDIR      := rmdir /s/q
FIND       := "${SystemRoot}\System32\find"
FINDSTR    := "${SystemRoot}\System32\findstr"
MORE       := "${SystemRoot}\System32\more"
SORT       := "${SystemRoot}\System32\sort"
#
ECHO_newline := echo.
else
OSID_name  ?= $(shell uname | tr '[:upper:]' '[:lower:]')
OS_PREFIX  := ${OSID_name}.
CC_e       := -o${SPACE}
CC_o       := -o${SPACE}
LD_o       := -o${SPACE}
EXEEXT     := $()
O          := o
#
AWK        := awk
CAT        := cat
CP         := cp
ECHO       := echo
GREP       := grep
MKDIR      := mkdir -p
RM         := rm
RM_r       := ${RM} -r
RMDIR      := ${RM} -r
SORT       := sort
#
ECHO_newline := echo
endif

# calculate `strip` for ${CC_ID} and ${OSID}
STRIP := $(or ${STRIP_CC_${CC_ID}_OSID_${OSID}}, ${STRIP_CC_${CC_ID}}, ${STRIP})
$(call %debug_var,STRIP)
# * and... ${STRIP} available? (missing in some distributions)
STRIP_check_flags := --version
STRIP := $(shell "${STRIP}" ${STRIP_check_flags} >${devnull} 2>&1 && echo ${STRIP})
$(call %debug_var,STRIP)

####

makefile_path := $(lastword ${MAKEFILE_LIST})
makefile_abs_path := $(abspath ${makefile_path})
makefile_dir := $(abspath $(dir ${makefile_abs_path}))
current_dir := ${CURDIR}
make_invoke_alias ?= $(if $(call %eq,Makefile,${makefile_path}),make,make -f "${makefile_path}")

$(call %debug_var,makefile_path)
$(call %debug_var,makefile_abs_path)
$(call %debug_var,makefile_dir)
$(call %debug_var,current_dir)
$(call %debug_var,current_dir)

####

NAME := $(strip ${NAME})
ifeq (${NAME},)
override NAME := $(notdir ${makefile_dir})
endif

####

ARCH_default := i686
ARCH_i686 := i686 x86
ARCH_x86_64 := x64 x86_64
ARCH_allowed := $(sort 32 x32 ${ARCH_i686} 64 ${ARCH_x86_64})
ifneq (${ARCH},$(filter ${ARCH},${ARCH_allowed}))
$(call %error,Unknown architecture "$(ARCH)"; valid values are [""$(subst $(SPACE),$(),$(addprefix ${COMMA}${DQUOTE},$(addsuffix ${DQUOTE},${ARCH_allowed})))])
endif

ifeq (${OSID},win)
CC_machine_raw := $(shell ${CC} ${CFLAGS_machine} 2>&1 | ${FINDSTR} /n /r .* | ${FINDSTR} /b /r "1:")
else ## nix
CC_machine_raw := $(shell ${CC} ${CFLAGS_machine} 2>&1 | ${GREP} -n ".*" | ${GREP} "^1:" )
endif
CC_machine_raw := $(subst ${ESC}1:,$(),${ESC}${CC_machine_raw})
CC_ARCH := $(or $(filter $(subst -, ,${CC_machine_raw}),${ARCH_i686} ${ARCH_x86_64}),${ARCH_default})
CC_machine := $(or $(and $(call %eq,cl,${CC}),${CC_ARCH}),${CC_machine_raw})
CC_ARCH_ID := $(if $(filter ${CC_ARCH},32 x32 ${ARCH_i686}),32,64)
override ARCH := $(or ${ARCH},${CC_ARCH})
ARCH_ID := $(if $(filter ${ARCH},32 x32 ${ARCH_i686}),32,64)

$(call %debug_var,CC_machine_raw)
$(call %debug_var,CC_machine)
$(call %debug_var,CC_ARCH)
$(call %debug_var,CC_ARCH_ID)

$(call %debug_var,ARCH)
$(call %debug_var,ARCH_ID)

####

# "version heuristic" => parse first line of ${CC} version output, remove all non-version-compatible characters, take first word that starts with number and contains a ${DOT}
# maint; [2020-05-14;rivy] heuristic is dependant on version output of various compilers; works for all known versions as of

ifeq (${OSID},win)
CC_version_raw := $(shell ${CC} ${CFLAGS_v} 2>&1 | ${FINDSTR} /n /r .* | ${FINDSTR} /b /r "1:")
else ## nix
CC_version_raw := $(shell ${CC} ${CFLAGS_v} 2>&1 | ${GREP} -n ".*" | ${GREP} "^1:" )
endif
$(call %debug_var,CC_version_raw)

s := ${CC_version_raw}

# remove "1:" leader
s := $(subst ${ESC}1:,$(),${ESC}${s})
# $(call %debug_var,s)
# remove all non-version-compatible characters (leaving common version characters [${BACKSLASH} ${SLASH} ${DOT} _ - +])
s := $(call %tr,$(filter-out ${SLASH} ${BACKSLASH} ${DOT} _ - +,${[punct]}),$(),${s})
# $(call %debug_var,s)
# filter_map ${DOT}-containing words
%f = $(and $(findstring ${DOT},${1}),${1})
s := $(call %filter_map,%f,${s})
$(call %debug_var,s)
# filter_map all words with leading digits
%f = $(and $(findstring ${ESC}_,${ESC}$(call %tr,${[digit]} ${ESC},$(call %repeat,_,$(words ${[digit]})),${1})),${1})
s := $(call %filter_map,%f,${s})
# $(call %debug_var,s)

# take first word as full version
CC_version := $(firstword ${s})
CC_version_parts := $(strip $(subst ${DOT},${SPACE},${CC_version}))
CC_version_M := $(strip $(word 1,${CC_version_parts}))
CC_version_m := $(strip $(word 2,${CC_version_parts}))
CC_version_r := $(strip $(word 3,${CC_version_parts}))
CC_version_Mm := $(strip ${CC_version_M}.${CC_version_m})

is_VC6 := $(and $(call %eq,cl,${CC}),$(call %eq,12,${CC_version_M}),${true})

$(call %debug_var,CC_version)
$(call %debug_var,CC_version_parts)
$(call %debug_var,CC_version_M)
$(call %debug_var,CC_version_m)
$(call %debug_var,CC_version_r)
$(call %debug_var,CC_version_Mm)
$(call %debug_var,is_VC6)

####

OUT_DIR_EXT := $(if $(call %is_truthy,${STATIC}),,.dynamic)

ifeq (,${TARGET})
OUT_DIR_EXT :=-x${ARCH_ID}
else
CFLAGS_TARGET := --target=${TARGET}
LDFLAGS_TARGET := --target=${TARGET}
OUT_DIR_EXT := ${OUT_DIR_EXT}.${TARGET}
endif

$(call %debug_var,CFLAGS_TARGET)
$(call %debug_var,CXXFLAGS_TARGET)
$(call %debug_var,LDFLAGS_TARGET)

$(call %debug_var,ARCH_ID)
$(call %debug_var,TARGET)

$(call %debug_var,OUT_DIR_EXT)

####

CFLAGS += ${CFLAGS_ARCH_${ARCH_ID}}
CFLAGS += ${CFLAGS_TARGET}
CFLAGS += ${CFLAGS_DEBUG_${DEBUG}}
CFLAGS += ${CFLAGS_DEBUG_${DEBUG}_STATIC_${STATIC}}
CFLAGS += ${CFLAGS_VERBOSE_${VERBOSE}}

CXXFLAGS += ${CXXFLAGS_${CC_ID}}

LDFLAGS += ${LDFLAGS_ARCH_${ARCH_ID}}
LDFLAGS += ${LDFLAGS_TARGET}
LDFLAGS += ${LDFLAGS_STATIC_${STATIC}}
LDFLAGS += ${LDFLAGS_VC6_${is_VC6}}
LDFLAGS += ${LDFLAGS_${CC_ID}}
LDFLAGS += ${LDFLAGS_${CC_ID}_${OSID}}

CFLAGS := $(strip ${CFLAGS})
CXXFLAGS := $(strip ${CXXFLAGS})
LDFLAGS := $(strip ${LDFLAGS})

$(call %debug_var,CFLAGS)
$(call %debug_var,CXXFLAGS)
$(call %debug_var,LDFLAGS)

####

# note: work within ${CURDIR} (build directories may not yet be created)
# note: set LIB as `make` doesn't export the LIB change into `$(shell ...)` invocations
test_file_stem := $(subst ${SPACE},_,__MAKE__${CC}_${ARCH}_${TARGET}_test__)
test_file_cc_string := ${CC_e}${test_file_stem}${EXEEXT}
test_success_text := ..TEST-COMPILE-SUCCESSFUL..
$(call %debug_var,test_file_stem)
$(call %debug_var,test_file_cc_string)
ifeq (${OSID},win)
# erase the LIB environment variable for non-`cl` compilers (specifically `clang` has issues)
test_lib_setting_win := $(if $(call %neq,cl,${CC}),set "LIB=${LIB}",set "LIB=%LIB%")
$(call %debug_var,test_lib_setting_win)
# test_output := $(shell ${test_lib_setting_win} && ${ECHO} ${HASH}include ^<stdio.h^> > ${test_file_stem}.c && ${ECHO} int main(void){printf("${test_file_stem}");return 0;} >> ${test_file_stem}.c && ${CC} $(filter-out ${CFLAGS_VERBOSE_true},${CFLAGS}) ${test_file_stem}.c ${test_file_cc_string} 2>&1 && ${ECHO} ${test_success_text})
test_output := $(shell ${test_lib_setting_win} && ${ECHO} ${HASH}include ^<stdio.h^> > ${test_file_stem}.c && ${ECHO} int main(void){printf("${test_file_stem}");return 0;} >> ${test_file_stem}.c && ${CC} $(filter-out ${CFLAGS_VERBOSE_true},${CFLAGS}) ${test_file_stem}.c ${test_file_cc_string} 2>&1 && ${ECHO} ${test_success_text}& ${RM} ${test_file_stem}${EXEEXT} ${test_file_stem}.*)
else
test_output := $(shell LIB='${LIB}' && ${ECHO} '${HASH}include <stdio.h>' > ${test_file_stem}.c && ${ECHO} 'int main(void){printf("${test_file_stem}");return 0;}' >> ${test_file_stem}.c && ${CC} $(filter-out ${CFLAGS_VERBOSE_true},${CFLAGS}) ${test_file_stem}.c ${test_file_cc_string} 2>&1 && ${ECHO} ${test_success_text}; ${RM} -f ${test_file_stem}${EXEEXT} ${test_file_stem}.*)
endif
ARCH_available := $(call %is_truthy,$(findstring ${test_success_text},${test_output}))
$(call %debug_var,.SHELLSTATUS)
$(call %debug_var,test_output)
$(call %debug_var,ARCH_available)

$(call %debug_var,ARCH_ID)
$(call %debug_var,CC_ARCH_ID)

ifeq (${false},$(and ${ARCH_available},$(or $(call %eq,${ARCH_ID},${CC_ARCH_ID}),$(call %neq,cl,${CC}))))
$(call %error,$(if ${TARGET},Architecture/Target "${ARCH}/${TARGET}",Architecture "${ARCH}") is unavailable/unimplemented for this version of `${CC}` (v${CC_version}/${CC_machine}))
endif

####

BUILD_DIR := ${HASH}build
CONFIG    := $(if $(call %is_truthy,${DEBUG}),debug,release)

SRC_DIR := .
OUT_DIR := .
OUT_bin := .
OUT_obj := .
out_dirs := $(strip $(call %uniq,${OUT_DIR} ${OUT_bin} ${OUT_obj}))
out_dirs_for_rules := $(strip $(subst ${HASH},${BACKSLASH}${HASH},${out_dirs}))

$(call %debug_var,out_dirs)
$(call %debug_var,out_dirs_for_rules)

SRC_files := $(wildcard ${SRC_DIR}/*.c ${SRC_DIR}/*.cpp ${SRC_DIR}/*.cxx)
OBJ_files := $(SRC_files)
OBJ_files := $(OBJ_files:${SRC_DIR}/%.c=${OUT_obj}/%.${O})
OBJ_files := $(OBJ_files:${SRC_DIR}/%.cpp=${OUT_obj}/%.${O})
OBJ_files := $(OBJ_files:${SRC_DIR}/%.cxx=${OUT_obj}/%.${O})

$(call %debug_var,SRC_DIR)
$(call %debug_var,SRC_files)
$(call %debug_var,OBJ_files)

####

PROJECT_TARGET := ${OUT_bin}/${NAME}${EXEEXT}
${PROJECT_TARGET}: # *default* target (see recipe/rule below)

####

AUX_names := lessecho lesskey
AUX_targets := $(addprefix ${OUT_bin}/,$(addsuffix ${EXEEXT},${AUX_names}))

$(call %debug_var,AUX_names)
$(call %debug_var,AUX_targets)

OBJ_files := $(filter-out $(addprefix ${SRC_DIR}/,$(addsuffix .c,${AUX_names} scrsize)),${SRC_files})
OBJ_files := $(OBJ_files:${SRC_DIR}/%.c=${OUT_obj}/%.${O})
OBJ_files := $(OBJ_files:${SRC_DIR}/%.cpp=${OUT_obj}/%.${O})
OBJ_files := $(OBJ_files:${SRC_DIR}/%.cxx=${OUT_obj}/%.${O})

$(call %debug_var,OBJ_files)

####

${AUX_targets}: %${EXEEXT}: %.${O} version.${O} ${makefile_abs_path} | ${OUT_bin}
	${LD} ${LDFLAGS} "$<" "version.${O}" ${LIBS} ${LD_o}"$@"
	$(if $(and ${STRIP},$(call %is_falsey,${DEBUG})),${STRIP} "$@",)
	@${ECHO} $(call %shell_quote,$(call %success_text,made '$@'.))

${OBJ_files}: ${OBJ_deps} | ${OUT_obj}

defines.h: defines.${DEFINETYPE}
	@${CP} defines.${DEFINETYPE} defines.h >${devnull}
	@${ECHO} $(call %shell_quote,$(call %info_text,created '$@' from '$<'.))

####

.PHONY: help
help: ## Display help
	@${ECHO} $(call %shell_quote,`${make_invoke_alias}`)
	@${ECHO} $(call %shell_quote,Usage: `${make_invoke_alias} [ARCH=..] [COLOR=..] [DEBUG=..] [STATIC=..] [TARGET=..] [VERBOSE=..] [MAKE_TARGET...]`)
	@${ECHO} $(call %shell_quote,Builds '${PROJECT_TARGET}' within "$(current_dir)")
	@${ECHO_newline}
	@${ECHO} $(call %shell_quote,MAKE_TARGETs:)
	@${ECHO_newline}
ifeq (${OSID},win)
	@${FINDSTR} "^[a-zA-Z-]*:.*${HASH}${HASH}" "${makefile_path}" | ${SORT} | for /f "tokens=1-2,* delims=:${HASH}" %%g in ('${MORE}') do @(@call set "t=%%g                " & @call echo ${color_success}%%t:~0,15%%${color_reset} ${color_info}%%i${color_reset})
else
	@${GREP} -P "(?i)^[[:alpha:]-]+:" "${makefile_path}" | ${SORT} | ${AWK} 'match($$0,"^([[:alpha:]]+):.*?${HASH}${HASH}\\s*(.*)$$",m){ printf "${color_success}%-10s${color_reset}\t${color_info}%s${color_reset}\n", m[1], m[2] }END{printf "\n"}'
endif

.PHONY: run
run: ${PROJECT_TARGET} ## Build/execute project executable
	@"$^"

####

.PHONY: clean
clean: ## Remove build artifacts (including intermediate files)
	@$(call %rm_fileset,*.${O})
	@$(call %rm_file,defines.h)
	@$(call %rm_file,${PROJECT_TARGET})
	@$(call %rm_files,${AUX_targets})

####

.PHONY: all build build-aux compile realclean rebuild vclean veryclean
all: build build-aux ## Build all project executables
build: ${PROJECT_TARGET} ## Build project (`less`)
build-aux: ${AUX_targets} ## Build auxillary executables (`lessecho` and `lesskey`)
compile: ${OBJ_files} ## Build intermediate files
realclean: clean
rebuild: clean build ## Clean and rebuild project
vclean: realclean
veryclean: realclean

####

# ref: [`make` default rules]<https://www.gnu.org/software/make/manual/html_node/Catalogue-of-Rules.html> @@ <https://archive.is/KDNbA>
# ref: [make ~ `eval()`](http://make.mad-scientist.net/the-eval-function) @ <https://archive.is/rpUfG>

${PROJECT_TARGET}: ${OBJ_files} ${makefile_abs_path} | ${OUT_bin}
	${LD} ${LDFLAGS} $(addprefix ",$(addsuffix ",${OBJ_files})) ${LIBS} ${LD_o}"$@"
	$(if $(and ${STRIP},$(call %is_falsey,${DEBUG})),${STRIP} "$@",)
	@${ECHO} $(call %shell_quote,$(call %success_text,made '$@'.))

${OUT_obj}/%.${O}: ${SRC_DIR}/%.c ${makefile_abs_path} | ${OUT_obj}
	${CC} ${CFLAGS_COMPILE_ONLY} ${CPPFLAGS} ${CFLAGS} "$<" ${CC_o}"$@"

${OUT_obj}/%.${O}: ${SRC_DIR}/%.cpp ${makefile_abs_path} | ${OUT_obj}
	${CXX} ${CFLAGS_COMPILE_ONLY} ${CPPFLAGS} ${CXXFLAGS} ${CFLAGS} "$<" ${CC_o}"$@"

${OUT_obj}/%.${O}: ${SRC_DIR}/%.cxx ${makefile_abs_path} | ${OUT_obj}
	${CXX} ${CFLAGS_COMPILE_ONLY} ${CPPFLAGS} ${CXXFLAGS} ${CFLAGS} "$<" ${CC_o}"$@"
#or ${CC} ${CFLAGS_COMPILE_ONLY} ${CPPFLAGS} ${CFLAGS} "$<" ${CC_o}"$@"

####

$(foreach dir,${out_dirs_for_rules},$(eval $(call @mkdir_rule,${dir})))
